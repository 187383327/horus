# -*- coding: utf-8 -*-
# This file is part of the Horus Project

__author__ = 'Jes√∫s Arroyo Torrens <jesus.arroyo@bq.com>'
__copyright__ = 'Copyright (C) 2014-2015 Mundo Reader S.L.'
__license__ = 'GNU General Public License v2 http://www.gnu.org/licenses/gpl2.html'

import cv2
import time
import struct
import platform
import threading
import numpy as np

system = platform.system()

from horus.engine.driver.driver import Driver
from horus.engine.calibration.pattern import Pattern

"""
    Calibrations:

        - Autocheck Algorithm
        - Camera Intrinsics Calibration
        - Laser Triangulation Calibration
        - Platform Extrinsics Calibration
"""


class Calibration(object):

    """Generic class for threading calibration"""

    def __init__(self):
        self.driver = Driver()
        self.pattern = Pattern()
        self.criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        # TODO: Callbacks to Observer pattern
        self._before_callback = None
        self._progress_callback = None
        self._after_callback = None
        self._is_calibrating = False

    def set_callbacks(self, before, progress, after):
        self._before_callback = before
        self._progress_callback = progress
        self._after_callback = after

    def start(self):
        if not self._is_calibrating:
            if self._before_callback is not None:
                self._before_callback()

            if self._progress_callback is not None:
                self._progress_callback(0)

            self._is_calibrating = True
            threading.Thread(target=self._start).start()

    def _start(self):
        pass

    def cancel(self):
        self._is_calibrating = False

    def detect_chessboard(self, frame):
        if self.pattern.rows <= 2 or self.pattern.columns <= 2:
            return False, frame, None
        if frame is not None:
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            ret, corners = cv2.findChessboardCorners(
                gray, (self.pattern.columns, self.pattern.rows), flags=cv2.CALIB_CB_FAST_CHECK)
            if ret:
                cv2.cornerSubPix(gray, corners, (11, 11), (-1, -1), self.criteria)
            return ret, frame, corners
        else:
            return False, frame, None

    def draw_chessboard(self, frame):
        retval, frame, corners = self.detect_chessboard(frame)
        if frame is not None:
            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        cv2.drawChessboardCorners(
            frame, (self.pattern.columns, self.pattern.rows), corners, retval)
        if frame is not None:
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        return retval, frame, corners

    def solve_pnp(self, frame):
        retval, frame, corners = self.detect_chessboard(frame)
        if retval:
            ret, rvecs, tvecs = cv2.solvePnP(
                self.pattern.object_points, corners,
                self.driver.camera.camera_matrix, self.driver.camera.distortion_vector)
            if ret is not None:
                return (cv2.Rodrigues(rvecs)[0], tvecs, corners)
            else:
                return None
        else:
            return None

    def corners_mask(self, frame, corners):
        p1 = corners[0][0]
        p2 = corners[self.pattern.columns - 1][0]
        p3 = corners[self.pattern.columns * (self.pattern.rows - 1) - 1][0]
        p4 = corners[self.pattern.columns * self.pattern.rows - 1][0]
        p11 = min(p1[1], p2[1], p3[1], p4[1])
        p12 = max(p1[1], p2[1], p3[1], p4[1])
        p21 = min(p1[0], p2[0], p3[0], p4[0])
        p22 = max(p1[0], p2[0], p3[0], p4[0])
        d = max(corners[1][0][0] - corners[0][0][0],
                corners[1][0][1] - corners[0][0][1],
                corners[self.pattern.columns][0][1] - corners[0][0][1],
                corners[self.pattern.columns][0][0] - corners[0][0][0])
        mask = np.zeros(frame.shape[:2], np.uint8)
        mask[p11 - d:p12 + d, p21 - d:p22 + d] = 255
        frame = cv2.bitwise_and(frame, frame, mask=mask)
        return frame

    def save_scene(self, filename, point_cloud):
        if point_cloud is not None:
            f = open(filename, 'wb')
            self.save_scene_stream(f, point_cloud)
            f.close()

    def save_scene_stream(self, stream, point_cloud):
        frame = "ply\n"
        frame += "format binary_little_endian 1.0\n"
        frame += "comment Generated by Horus software\n"
        frame += "element vertex {0}\n".format(len(point_cloud))
        frame += "property float x\n"
        frame += "property float y\n"
        frame += "property float z\n"
        frame += "property uchar red\n"
        frame += "property uchar green\n"
        frame += "property uchar blue\n"
        frame += "element face 0\n"
        frame += "property list uchar int vertex_indices\n"
        frame += "end_header\n"
        for point in point_cloud:
            frame += struct.pack("<fffBBB", point[0], point[1], point[2], 255, 0, 0)
        stream.write(frame)
