# -*- coding: utf-8 -*-
# This file is part of the Horus Project

__author__ = 'Jes√∫s Arroyo Torrens <jesus.arroyo@bq.com>'
__copyright__ = 'Copyright (C) 2014-2015 Mundo Reader S.L.'
__license__ = 'GNU General Public License v2 http://www.gnu.org/licenses/gpl2.html'

import cv2
import time
import struct
import platform
import threading
import numpy as np
from scipy import optimize
from scipy.sparse import linalg

system = platform.system()

from horus.engine.driver.driver import Driver
from horus.engine.calibration.pattern import Pattern

"""
    Calibrations:

        - Autocheck Algorithm
        - Camera Intrinsics Calibration
        - Laser Triangulation Calibration
        - Platform Extrinsics Calibration
"""


class Calibration(object):

    """Generic class for threading calibration"""

    def __init__(self):
        self.driver = Driver()
        self.pattern = Pattern()
        self.criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
        # TODO: Callbacks to Observer pattern
        self._before_callback = None
        self._progress_callback = None
        self._after_callback = None
        self._is_calibrating = False

    def set_callbacks(self, before, progress, after):
        self._before_callback = before
        self._progress_callback = progress
        self._after_callback = after

    def start(self):
        if not self._is_calibrating:
            if self._before_callback is not None:
                self._before_callback()

            if self._progress_callback is not None:
                self._progress_callback(0)

            self._is_calibrating = True
            threading.Thread(target=self._start).start()

    def _start(self):
        pass

    def cancel(self):
        self._is_calibrating = False

    def detect_chessboard(self, frame):
        if self.pattern.rows <= 2 or self.pattern.columns <= 2:
            return False, frame, None
        if frame is not None:
            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            ret, corners = cv2.findChessboardCorners(
                gray, (self.pattern.columns, self.pattern.rows), flags=cv2.CALIB_CB_FAST_CHECK)
            if ret:
                cv2.cornerSubPix(gray, corners, (11, 11), (-1, -1), self.criteria)
            return ret, frame, corners
        else:
            return False, frame, None

    def draw_chessboard(self, frame):
        retval, frame, corners = self.detect_chessboard(frame)
        if frame is not None:
            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
        cv2.drawChessboardCorners(
            frame, (self.pattern.columns, self.pattern.rows), corners, retval)
        if frame is not None:
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        return retval, frame, corners

    def solve_pnp(self, frame):
        retval, frame, corners = self.detect_chessboard(frame)
        if retval:
            ret, rvecs, tvecs = cv2.solvePnP(
                self.pattern.object_points, corners,
                self.driver.camera.camera_matrix, self.driver.camera.distortion_vector)
            if ret is not None:
                return (cv2.Rodrigues(rvecs)[0], tvecs, corners)
            else:
                return None
        else:
            return None

    def corners_mask(self, frame, corners):
        p1 = corners[0][0]
        p2 = corners[self.pattern.columns - 1][0]
        p3 = corners[self.pattern.columns * (self.pattern.rows - 1) - 1][0]
        p4 = corners[self.pattern.columns * self.pattern.rows - 1][0]
        p11 = min(p1[1], p2[1], p3[1], p4[1])
        p12 = max(p1[1], p2[1], p3[1], p4[1])
        p21 = min(p1[0], p2[0], p3[0], p4[0])
        p22 = max(p1[0], p2[0], p3[0], p4[0])
        d = max(corners[1][0][0] - corners[0][0][0],
                corners[1][0][1] - corners[0][0][1],
                corners[self.pattern.columns][0][1] - corners[0][0][1],
                corners[self.pattern.columns][0][0] - corners[0][0][0])
        mask = np.zeros(frame.shape[:2], np.uint8)
        mask[p11 - d:p12 + d, p21 - d:p22 + d] = 255
        frame = cv2.bitwise_and(frame, frame, mask=mask)
        return frame

    def save_scene(self, filename, point_cloud):
        if point_cloud is not None:
            f = open(filename, 'wb')
            save_scene_stream(f, point_cloud)
            f.close()

    def save_scene_stream(self, stream, point_cloud):
        frame = "ply\n"
        frame += "format binary_little_endian 1.0\n"
        frame += "comment Generated by Horus software\n"
        frame += "element vertex {0}\n".format(len(point_cloud))
        frame += "property float x\n"
        frame += "property float y\n"
        frame += "property float z\n"
        frame += "property uchar red\n"
        frame += "property uchar green\n"
        frame += "property uchar blue\n"
        frame += "element face 0\n"
        frame += "property list uchar int vertex_indices\n"
        frame += "end_header\n"
        for point in point_cloud:
            frame += struct.pack("<fffBBB", point[0], point[1], point[2], 255, 0, 0)
        stream.write(frame)


def detect_pattern_plane(image):
    if image is not None:
        ret = solve_pnp(image)
        if ret is not None:
            R = ret[0]
            t = ret[1].T[0]
            n = R.T[2]
            c = ret[2]
            d = -np.dot(n, t)
            return (d, n, c)


def compute_laser_line(img_las, img_raw, threshold):
    # Image segmentation
    sub = cv2.subtract(img_las, img_raw)
    r, g, b = cv2.split(sub)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2))
    r = cv2.morphologyEx(r, cv2.MORPH_OPEN, kernel)
    r = cv2.threshold(r, threshold, 255.0, cv2.THRESH_TOZERO)[1]

    # Peak detection: center of mass
    h, w = r.shape
    W = np.array((np.matrix(np.linspace(0, w - 1, w)).T * np.matrix(np.ones(h))).T)
    s = r.sum(axis=1)
    v = np.where(s > 0)[0]
    u = (W * r).sum(axis=1)[v] / s[v]

    return u, v


def compute_point_cloud(u, v, d, n):
    fx = driver.camera.camera_matrix[0][0]
    fy = driver.camera.camera_matrix[1][1]
    cx = driver.camera.camera_matrix[0][2]
    cy = driver.camera.camera_matrix[1][2]

    x = np.concatenate(((u - cx) / fx, (v - cy) / fy, np.ones(len(u)))).reshape(3, len(u))

    X = -d / np.dot(n, x) * x

    return X.T


def compute_plane(X, side):
    if X is not None:
        X = np.matrix(X).T
        n = X.shape[1]
        std = 0
        if n > 3:
            final_points = []

            for trials in xrange(30):
                X = np.matrix(X)
                n = X.shape[1]

                Xm = X.sum(axis=1) / n
                M = np.array(X - Xm)
                U = linalg.svds(M, k=2)[0]
                s, t = U.T
                n = np.cross(s, t)
                if n[2] < 0:
                    n *= -1
                d = np.dot(n, np.array(Xm))[0]
                distance_vector = np.dot(M.T, n)

                # If last std is equal to current std, break loop
                if std == distance_vector.std():
                    break

                std = distance_vector.std()

                final_points = np.where(abs(distance_vector) < abs(2 * std))[0]

                X = X[:, final_points]

                # Save each iteration point cloud
                # if side == 'l':
                #   save_scene('new_'+str(trials)+'_XL.ply', np.asarray(X.T))
                # else:
                #   save_scene('new_'+str(trials)+'_XR.ply', np.asarray(X.T))

                if std < 0.1 or len(final_points) < 1000:
                    break

            return d, n, std
        else:
            return None, None, None
    else:
        return None, None, None
